/* Generated by Frama-C */
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
typedef __mpz_struct ( __attribute__((__FC_BUILTIN__)) mpz_t)[1];
typedef unsigned int size_t;
typedef unsigned int ino_t;
typedef unsigned int gid_t;
typedef unsigned int uid_t;
typedef long time_t;
typedef unsigned int blkcnt_t;
typedef unsigned int blksize_t;
typedef unsigned int dev_t;
typedef unsigned int mode_t;
typedef unsigned int nlink_t;
typedef unsigned int off_t;
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   time_t st_atime ;
   time_t st_mtime ;
   time_t st_ctime ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   char *__fc_real_data ;
   int __fc_real_data_max_size ;
};
struct __fc_FILE {
   unsigned int __fc_stdio_id ;
   unsigned int __fc_maxsz ;
   unsigned int __fc_writepos ;
   unsigned int __fc_readpos ;
   int __fc_is_a_socket ;
   int mode ;
   struct stat *__fc_inode ;
};
typedef struct __fc_FILE FILE;
/*@ requires predicate ≢ 0;
    assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void e_acsl_assert(int predicate,
                                                           char *kind,
                                                           char *fct,
                                                           char *pred_txt,
                                                           int line);

/*@
model __mpz_struct { ℤ n };
*/
int __fc_random_counter __attribute__((__unused__));
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures 0 ≤ \result ∧ \result ≤ __fc_rand_max;
    assigns __fc_random_counter;
    assigns \result \from __fc_random_counter;
 */
extern int rand(void);

/*@ ensures 0 ≤ \result ∧ \result ≤ __fc_rand_max;
    assigns __fc_random_counter;
    assigns \result \from __fc_random_counter;
 */
int __e_acsl_rand(void)
{
  int __retres;
  __retres = rand();
  {
    int __e_acsl_and;
    if (0 <= __retres) __e_acsl_and = (unsigned long)__retres <= __fc_rand_max;
    else __e_acsl_and = 0;
    e_acsl_assert(__e_acsl_and,(char *)"Postcondition",(char *)"rand",
                  (char *)"0 <= \\result && \\result <= __fc_rand_max",103);
    return __retres;
  }
}

/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic
  dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }

*/
/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from size, __fc_heap_status;
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from size, __fc_heap_status;
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
extern void *__malloc(size_t size);

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes p ≢ \null;
      requires \freeable(p);
      ensures \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
extern void __free(void *p);

/*@ assigns \result \from *((char *)ptr+(0..size-1)); */
extern  __attribute__((__FC_BUILTIN__)) void *__store_block(void *ptr,
                                                            size_t size);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __full_init(void *ptr);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __literal_string(void *ptr);

extern size_t __memory_size;

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from size, __fc_heap_status;
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from size, __fc_heap_status;
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *__e_acsl_malloc(size_t size)
{
  void *__retres;
  __retres = __malloc(size);
  return __retres;
}

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes p ≢ \null;
      requires \freeable(p);
      ensures \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
void __e_acsl_free(void *p)
{
  int __e_acsl_at;
  __e_acsl_at = p != (void *)0;
  __free(p);
  return;
}

/*@
predicate diffSize{L1, L2}(ℤ i) =
  \at(__memory_size,L1)-\at(__memory_size,L2) ≡ i;

*/
extern FILE *__fc_stdout;

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from *(format+(..)); */
extern int printf(char const *format , ...);

int sum(int *A, int length);

void multiply(int *A, int factor, int length);

void permute(int *A, int length);

void arrcpy(int *A1, int *A2, int length)
{
  int i;
  i = 0;
  while (i < length) {
    *(A2 + i) = *(A1 + i);
    i ++;
  }
  return;
}

int check_sum_double_is_double(int *A, int length)
{
  char *__e_acsl_literal_string_2;
  char *__e_acsl_literal_string;
  int __retres;
  int A2[1];
  void *tmp;
  int r1;
  int r2;
  tmp = __e_acsl_malloc((unsigned int)(sizeof(int) * (unsigned long)length));
  A2[0] = (int)tmp;
  arrcpy(A,A2,length);
  multiply(A2,2,length);
  r1 = sum(A,length);
  r2 = sum(A2,length);
  __e_acsl_literal_string = "*** original sum is: %d\n";
  __store_block((void *)__e_acsl_literal_string,
                (size_t)sizeof("*** original sum is: %d\n"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  printf(__e_acsl_literal_string,r1);
  __e_acsl_literal_string_2 = "*** modified sum is: %d\n";
  __store_block((void *)__e_acsl_literal_string_2,
                (size_t)sizeof("*** modified sum is: %d\n"));
  __full_init((void *)__e_acsl_literal_string_2);
  __literal_string((void *)__e_acsl_literal_string_2);
  printf(__e_acsl_literal_string_2,r2);
  /*@ assert r1*2 ≡ r2; */
  e_acsl_assert((long)r1 * (long)2 == (long)r2,(char *)"Assertion",
                (char *)"check_sum_double_is_double",(char *)"r1*2 == r2",26);
  __e_acsl_free((void *)(A2));
  __retres = 0;
  return __retres;
}

int sum(int *A, int length)
{
  int i;
  int sum_0;
  sum_0 = 0;
  i = 0;
  while (i < length) {
    sum_0 += *(A + i);
    i ++;
  }
  return sum_0;
}

void multiply(int *A, int factor, int length)
{
  int i;
  i = 0;
  while (i < length) {
    *(A + i) *= factor;
    i ++;
  }
  return;
}

void permute(int *A, int length)
{
  int i;
  i = 0;
  while (i < length) {
    {
      int which;
      int tmp;
      int temp;
      {
        /*undefined sequence*/
        tmp = __e_acsl_rand();
        ;
      }
      which = tmp % length;
      temp = *(A + i);
      *(A + i) = *(A + which);
      *(A + which) = temp;
    }
    i ++;
  }
  return;
}

int main(void)
{
  char *__e_acsl_literal_string;
  int __retres;
  int a[3];
  int tmp;
  a[0] = 1;
  a[1] = 2;
  a[2] = 3;
  tmp = sum(a,3);
  __e_acsl_literal_string = "The sum is: %d\n";
  __store_block((void *)__e_acsl_literal_string,
                (size_t)sizeof("The sum is: %d\n"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  printf(__e_acsl_literal_string,tmp);
  check_sum_double_is_double(a,3);
  __retres = 0;
  return __retres;
}


